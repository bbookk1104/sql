-- DML
-- 회원(이름,나이,주소,성별,아이디,패스워드,가입일)
CREATE TABLE MEMBER_TBL(
    MEMBER_ID   VARCHAR2(20),       -- 아이디
    MEMBER_PW   VARCHAR2(30),       -- 비밀번호
    MEMBER_NAME VARCHAR2(20),       -- 이름
    MEMBER_AGE  NUMBER,             -- 나이
    ADDRESS     VARCHAR2(500),      -- 주소
    GENDER      CHAR(6),            -- 성별
    ENROLL_DATE DATE                -- 가입일
);

-- INSERT : 테이블에 데이터를 삽입하는 구문 -> INSERT하는만큼 ROW수가 증가한다.
-- 1) INSERT INTO 테이블이름(컬럼이름1, 컬럼이름2 ....) VALUES(값1, 값2 .....);
-- * 컬럼명 명시, 순서 지키기 중요
INSERT INTO MEMBER_TBL(MEMBER_ID, MEMBER_PW, MEMBER_NAME,
                       MEMBER_AGE, ADDRESS, GENDER, ENROLL_DATE)
                VALUES('user01','1234','유저1', 20, '서울시 영등포구 당산동','여자',sysdate);
INSERT INTO MEMBER_TBL(MEMBER_NAME, MEMBER_AGE, ADDRESS, GENDER,
                       MEMBER_ID, MEMBER_PW, ENROLL_DATE)
                VALUES('유저2', 25, '서울시 마포구', '여자', 'user02', '11111', sysdate);
INSERT INTO MEMBER_TBL(MEMBER_ID, MEMBER_PW, MEMBER_NAME)
                VALUES('user03', '33333', '유저3');
INSERT INTO MEMBER_TBL(MEMBER_NAME, MEMBER_AGE, GENDER)
                VALUES('유저4', 22, '남자');
-- 2) INSERT INTO 테이블명 VALUES(값1, 값2, 값3...);
-- 모든 컬럼의 값을 테이블의 컬럼 순서대로 모두 입력(컬럼을 명시하지 않았기때문에 순서와 개수 모두 일치해야 함)
INSERT INTO MEMBER_TBL VALUES('user05','5555','유저5',40,'서울시','여자',SYSDATE);
INSERT INTO MEMBER_TBL VALUES('user06','6666','유저6',NULL,NULL,NULL,NULL);

SELECT * FROM MEMBER_TBL;

UPDATE MEMBER_TBL SET MEMBER_AGE=35, GENDER ='여자', ADDRESS='서울시',
       ENROLL_DATE=SYSDATE-1 WHERE MEMBER_ID = 'user03';

UPDATE MEMBER_TBL SET MEMBER_ID='user04', MEMBER_PW='4444', ADDRESS='서울시',
       ENROLL_DATE=SYSDATE WHERE MEMBER_NAME = '유저4';
--------------------------------------------------------------------------------

CREATE TABLE TEST_USER_TBL(
    USER_NO     NUMBER,         -- 회원번호
    JOIN_DATE   DATE,           -- 가입일
    USER_ID     VARCHAR2(30),   -- 아이디
    PASSWORD    VARCHAR2(20),   -- 비밀번호
    NICKNAME    VARCHAR2(20),   -- 별명
    PHONE       CHAR(13),       -- 전화번호(010-0000-0000 형식)
    AGE         NUMBER          -- 나이
);

INSERT INTO TEST_USER_TBL VALUES(01,SYSDATE,'user01',11111,'빡빡이','010-1111-1111',23);
INSERT INTO TEST_USER_TBL(USER_ID,PASSWORD,JOIN_DATE,NICKNAME) VALUES('user02','2222',sysdate,'뽞뽞이');
INSERT INTO TEST_USER_TBL VALUES(NULL,NULL,NULL,NULL,NULL,NULL,NULL);
INSERT INTO TEST_USER_TBL VALUES(3,SYSDATE,'user03',3321,'김덕팔','010-3211-3311',38);
INSERT INTO TEST_USER_TBL VALUES(4,SYSDATE,'user04',4455555,'박수박','010-2626-4444',43);
INSERT INTO TEST_USER_TBL VALUES(5,SYSDATE,'user05','abc55','고양이','010-9090-9090',7);
INSERT INTO TEST_USER_TBL VALUES(6,SYSDATE,'user06',123456,'이땃쥐','010-6253-1253',20);
INSERT INTO TEST_USER_TBL VALUES(7,SYSDATE,'user07',171717,'장덕만','010-1717-1717',17);
INSERT INTO TEST_USER_TBL VALUES(08,SYSDATE,'user08',8888,'강일수','010-8888-8888',82);
INSERT INTO TEST_USER_TBL VALUES(09,SYSDATE,'user09',9999,'최미애','010-9111-1119',25);

SELECT * FROM TEST_USER_TBL;

-- 수정
-- UPDATE 테이블이름 SET 수정할컬럼이름 = 수정값, 수정할컬럼이름2 = 수정값2 WHERE 조건;
-- UPDATE MEMBER_TBL SET MEMBER_AGE = 50; -> 전부 50살 되버림...
-- UPDATE MEMBER_TBL SET MEMBER_AGE = 50 WHERE MEMBER_ID = 'user02';
UPDATE TEST_USER_TBL SET USER_NO = 10, PHONE = '010-4432-2344', AGE = 22 WHERE USER_ID = 'user02';
UPDATE TEST_USER_TBL SET JOIN_DATE = SYSDATE+1, USER_ID = 'user10' WHERE USER_NO = 10;

-- DELETE : ROW수 감소
-- DELETE FROM 테이블명 WHERE 조건
DELETE FROM MEMBER_TBL WHERE MEMBER_ID = 'user06';

COMMIT;
ROLLBACK;

-- CREATE는 관리자 계정(admin)에서
--------------------------------------------------------------------------------
SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM JOB;
-- 전 직원의 이름,부서명(DEPARTMENT),직급명(JOB),급여 출력
-- 1) JOIN으로 했을 때
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM EMPLOYEE
    LEFT JOIN department ON (DEPT_CODE=DEPT_ID)
    JOIN JOB USING(JOB_CODE);
-- 2) SUBQUERY로 했을 때
SELECT
    EMP_NAME,
    (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_ID = E.DEPT_CODE) AS DEPT_TITLE,
    (SELECT JOB_NAME FROM JOB J WHERE J.JOB_CODE = E.JOB_CODE)AS JOB_NAME,
    SALARY
FROM EMPLOYEE E;

-- SUBQUERY로 테이블을 생성하는 경우 컬럼이름, 데이터타입, 값 복사 가능
-- 제약조건은 NOT NULL만 복사 가능!
CREATE TABLE EMP_COPY
AS -- 아래 결과 그대로 테이블이 만들어짐
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM EMPLOYEE
    LEFT JOIN department ON (DEPT_CODE=DEPT_ID)
    JOIN JOB USING(JOB_CODE);
SELECT * FROM EMP_COPY;

CREATE TABLE EMP_COPY2
AS
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE WHERE 1=0;
-- 구조만 필요하고 내부데이터가 필요없는 경우 일부러 항상 FALSE가 나오는 조건 사용(1=0)
SELECT * FROM EMP_COPY2;

CREATE TABLE EMP_COPY3
AS
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE WHERE 1=0;

CREATE TABLE EMP_COPY4
AS
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE WHERE 1=0;

INSERT ALL
INTO EMP_COPY3 VALUES(EMP_NAME, DEPT_CODE,SALARY) -- 2.EMP_COPY3에 값 넣어줌 - 23개
INTO EMP_COPY4 VALUES(EMP_NAME, JOB_CODE, SALARY) -- 3.EMP_COPY4에 값 넣어줌 - 23개
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY FROM EMPLOYEE; -- 1.실행    - 총 46개
SELECT * FROM EMP_COPY3;
SELECT * FROM EMP_COPY4;

-- ALTER : 데이터베이스 객체 정보 수정(UPDATE는 데이터 수정)
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT;
SELECT * FROM DEPT_COPY;

-- ADD : 테이블 컬럼(KNAME)을 추가
ALTER TABLE DEPT_COPY
ADD (KNAME VARCHAR2(20));
ALTER TABLE DEPT_COPY
ADD (HNAME VARCHAR2(20) DEFAULT 'HI'); -- NULL대신 넣는 값

-- MODIFY : 테이블 컬럼 자료형 변경
DESC DEPT_COPY;
-- DESC : 현재 자료형 간단히 확인
ALTER TABLE DEPT_COPY
MODIFY DEPT_TITLE VARCHAR2(50);

-- 제약조건 확인
SELECT
    UC.CONSTRAINT_NAME,
    UC.CONSTRAINT_TYPE,
    UCC.COLUMN_NAME,
    UC.SEARCH_CONDITION
FROM USER_CONSTRAINTS UC
JOIN USER_CONS_COLUMNS UCC
ON (UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
WHERE UC.TABLE_NAME = 'DEPT_COPY'; --*주의 : 테이블 이름 무조건 대문자로 입력*

-- 제약조건 추가[ADD CONSTRAINT]
SELECT * FROM DEPT_COPY;
ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_ID_PK PRIMARY KEY(DEPT_ID);

ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_TITLE_UNQ UNIQUE(DEPT_TITLE);
-- NOT NULL제약조건은 ADD가 아닌 [MODIFY]로 추가
ALTER TABLE DEPT_COPY
MODIFY HNAME CONSTRAINT DCOPY_HNAME_NN NOT NULL;

-- 제약조건은 수정의 개념X, 없애고 다시 추가해야 함
-- 제약조건 제거
ALTER TABLE DEPT_COPY
DROP CONSTRAINT DCOPY_ID_PK;
ALTER TABLE DEPT_COPY
DROP CONSTRAINT DCOPY_TITLE_UNQ;
-- NOT NULL제약조건은 DROP이 아닌 [MODIFY]로 삭제
ALTER TABLE DEPT_COPY
MODIFY HNAME NULL;
-- 제약조건 한번에 다 추가
ALTER TABLE DEPT_COPY
ADD CONSTRAINT DCOPY_ID_PK PRIMARY KEY(DEPT_ID)
ADD CONSTRAINT DCOPY_TITLE_UNQ UNIQUE(DEPT_TITLE)
MODIFY HNAME CONSTRAINT DCOPY_HNAME_NN NOT NULL;
-- 제약조건 한번에 다 삭제
ALTER TABLE DEPT_COPY
DROP CONSTRAINT DCOPY_ID_PK
DROP CONSTRAINT DCOPY_TITLE_UNQ
MODIFY HNAME NULL;

-- 컬럼 삭제
ALTER TABLE DEPT_COPY
DROP COLUMN KNAME;
SELECT * FROM DEPT_COPY;

-- 컬럼 이름 수정, 제약조건 이름 수정, 테이블 이름 수정
-- HNAME -> KHNAME
ALTER TABLE DEPT_COPY
RENAME COLUMN HNAME TO KHNAME;
DESC DEPT_COPY;
-- SYS C007070 -> DEPT_ID_NN
ALTER TABLE DEPT_COPY
RENAME CONSTRAINT SYS_C007070 TO DEPT_ID_NN;
-- DEPT_COPY -> ALTER_TEST
ALTER TABLE DEPT_COPY
RENAME TO ALTER_TEST;
SELECT * FROM ALTER_TEST;

-- TRUNCATE : 테이블 전체 행 삭제
-- DELETE에서 WHERE을 사용하지 않은 것과 차이점 :
-- 1. TRUNCATE가 수행속도 빠름
-- 2. 상황에 따라서 DELETE는 데이터 복구 가능, TRUNCATE는 데이터 복구 불가능!
TRUNCATE TABLE ALTER_TEST;

-- DROP : 데이터베이스 객체 삭제(테이블과 테이블 내부 데이터 모두 삭제)
DROP TABLE ALTER_TEST;
--------------------------------------------------------------------------------
-- DDL_DML 실습
CREATE TABLE RUNNINGMAN(
    NO NUMBER PRIMARY KEY,
    ID VARCHAR2(20) UNIQUE,
    PASS VARCHAR2(20) NOT NULL,
    NAME VARCHAR2(20) NOT NULL,
    NICKNAME VARCHAR2(20) UNIQUE,
    GENDER CHAR(1),
    TEL VARCHAR2(20) DEFAULT '010-0000-0000',
    ADDRESS VARCHAR2(90)
);

INSERT INTO RUNNINGMAN VALUES(
    1, 'muhan', '1234', '유재석', '못생긴형', 'M', '010-4958-2333', '압구정');
INSERT INTO RUNNINGMAN VALUES(
    2, 'bignose', '4444', '지석진', '지는해', 'M', default , '서울');
INSERT INTO RUNNINGMAN VALUES(
    3, 'tiger', '6658', '김종국', '안꼬', 'M', '010-6674-8986', '안양');
INSERT INTO RUNNINGMAN VALUES(
    4, 'haha', '5356', '하하', '신분세탁', 'M', '010-8997-1122', '서래마을');
INSERT INTO RUNNINGMAN VALUES(
    5, 'ace', '5555', '송지효', '천성임', 'F', default, '서울시');
INSERT INTO RUNNINGMAN VALUES(
    6, 'girrafe', '6658', '이광수', '중기친구', 'M', '010-2378-9991', '남양주');
INSERT INTO RUNNINGMAN VALUES(
    7, 'ssapssap', '5356', '양세찬', '김종국팬', 'M', '010-1215-7777', '동두천');
INSERT INTO RUNNINGMAN VALUES(
    8, 'doli', '5555', '전소민', '전두릅', 'F', default, '일산');

UPDATE RUNNINGMAN SET PASS = '9999' WHERE NICKNAME = '중기친구';
UPDATE RUNNINGMAN SET TEL = '없음' WHERE TEL = '010-0000-0000';

DELETE FROM RUNNINGMAN WHERE NAME = '유재석';

SELECT * FROM RUNNINGMAN;
--------------------------------------------------------------------------------
CREATE TABLE USER_TBL(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20)UNIQUE NOT NULL,
    USER_PW VARCHAR2(30)NOT NULL
);
INSERT INTO USER_TBL VALUES(1,'user01','1111');
INSERT INTO USER_TBL VALUES(2,'user02','2222');
INSERT INTO USER_TBL VALUES(3,'user03','3333');
INSERT INTO USER_TBL VALUES(4,'user04','4444');
INSERT INTO USER_TBL VALUES(5,'user05','4444');
COMMIT; -- TCL은 DDL에만 영향
INSERT INTO USER_TBL VALUES(6,'user06','4444');
SELECT USER_NO_SEQ.NEXTVAL FROM DUAL;
INSERT INTO USER_TBL VALUES(8,'user08','4444');
ROLLBACK; -- 마지막으로 COMMIT한 시점으로 되돌아감
UPDATE USER_TBL SET USER_PW = '5555' WHERE USER_NO=5;
UPDATE USER_TBL SET USER_PW = '6666' WHERE USER_NO=6;
UPDATE USER_TBL SET USER_PW = '7777' WHERE USER_NO=7;
UPDATE USER_TBL SET USER_PW = '8888' WHERE USER_NO=8;

DELETE FROM USER_TBL WHERE USER_NO=6;

SELECT * FROM USER_TBL;

SAVEPOINT SP1;
ROLLBACK TO SP1;
--------------------------------------------------------------------------------
-- VIEW : 테이블 데이터 상호영향O
CREATE OR REPLACE VIEW EMP_VIEW -- CREATE OR REPLACE 없으면 새로 생성, 이미 존재하면 갱신
AS 
SELECT EMP_ID, EMP_NAME, PHONE, SALARY FROM EMPLOYEE;

CREATE TABLE EMP_COPY5 -- 깊은 복사(데이터 복사 - 상호영향X 독립적인 데이터)
AS
SELECT EMP_ID, EMP_NAME, PHONE, SALARY FROM EMPLOYEE;

SELECT * FROM EMPLOYEE;
SELECT * FROM EMP_VIEW;
SELECT * FROM EMP_COPY5;

UPDATE EMP_COPY5 SET SALARY = 7000000 WHERE EMP_ID = 200;
UPDATE EMP_VIEW SET SALARY = 9000000 WHERE EMP_ID = 200;
--------------------------------------------------------------------------------
-- SEQUENCE : 순차적으로 정수 값을 자동으로 생성하는 객체
/*
CREATE SEQUENCE 시퀀스이름; --1부터 시작해서 1씩 증하는 시퀀스 생성

CREATE SEQUENCE 시퀀스이름
START WITH 숫자          -- 시퀀스 시작번호 설정
INCREMENT BY 숫자        -- 다음숫자 발생시 증가폭
MAXVALUE 숫자            -- 시퀀스가 발생시키는 숫자의 최대값
[CYCLE | NOCYCLE]       -- CYCLE : 최대값 도달시 이후에 다시 START부터 시작 / NOCYCLE: 에러발생
[CACHE | NOCACHE]       -- 시퀀스 값을 메모리에서 처리할지 결정
*/
CREATE SEQUENCE USER_NO_SEQ
START WITH 10
INCREMENT BY 10
MAXVALUE 100
NOCYCLE
NOCACHE;
DROP SEQUENCE USER_NO_SEQ;

SELECT USER_NO_SEQ.NEXTVAL FROM DUAL; -- .NEXTVAL 다음값 줘! 할 때마다 증가폭만큼 증가
SELECT USER_NO_SEQ.CURRVAL FROM DUAL; -- 현재 값 나타냄
INSERT INTO USER_TBL VALUES(USER_NO_SEQ.NEXTVAL,'user10','4444');
-- INSERT실패해도 SEQUENCE는 독립적으로 작동함
SELECT * FROM USER_TBL;

-- 시퀀스 생성
-- 시퀀스 이름 : SEQ_TEST_NO
-- 시작번호 : 1, 증가값 : 5, 최대값 100, NOCYCLE, NOCACHE
CREATE SEQUENCE SEQ_TEST_NO
START WITH 1
INCREMENT BY 5
MAXVALUE 100
NOCYCLE
NOCACHE;

ALTER SEQUENCE SEQ_TEST_NO -- START WITH는 못 고침
INCREMENT BY 10
MAXVALUE 100
NOCYCLE
NOCACHE;

SELECT SEQ_TEST_NO.NEXTVAL FROM DUAL;
SELECT SEQ_TEST_NO.CURRVAL FROM DUAL;
DROP SEQUENCE SEQ_TEST_NO;
--
CREATE TABLE KH_MEMBER(
    MEMBER_ID   NUMBER,
    MEMBER_NAME VARCHAR2(20),
    MEMBER_AGE  NUMBER,
    MEMBER_JOIN_COM NUMBER
);
CREATE SEQUENCE KH_MEMBER_ID
START WITH 500
INCREMENT BY 10
MAXVALUE 10000
NOCYCLE
NOCACHE;

CREATE SEQUENCE KH_MEMBER_JOIN_COM
START WITH 1
INCREMENT BY 1
MAXVALUE 10000
NOCYCLE
NOCACHE;

SELECT KH_MEMBER_ID.NEXTVAL FROM DUAL;
SELECT KH_MEMBER_ID.CURRVAL FROM DUAL;
DROP SEQUENCE KH_MEMBER_ID;
SELECT KH_MEMBER_JOIN_COM.NEXTVAL FROM DUAL;
SELECT KH_MEMBER_JOIN_COM.CURRVAL FROM DUAL;
DROP SEQUENCE KH_MEMBER_JOIN_COM;

INSERT INTO KH_MEMBER VALUES(KH_MEMBER_ID.NEXTVAL,'고길똥',24,KH_MEMBER_JOIN_COM.NEXTVAL);

SELECT * FROM KH_MEMBER;
--------------------------------------------------------------------------------
-- INDEX : 검색의 속도를 향상시키기 위해 사용
CREATE INDEX EMP_IDX
ON
EMPLOYEE(EMP_NAME, EMP_NO, HIRE_DATE);
DROP INDEX EMP_IDX;
SELECT EMP_NAME, EMP_NO, HIRE_DATE FROM EMPLOYEE;
--------------------------------------------------------------------------------
-- SYNONYM : '동의어', 별칭 설정해주는 기능
SELECT * FROM EMPLOYEE;
SELECT * FROM EMP;
SELECT * FROM DEPT;
CREATE SYNONYM EMP FOR EMPLOYEE; -- 비공개동의어(공개동의어는 관리자가 만듬)
DROP SYNONYM EMP;
--------------------------------------------------------------------------------