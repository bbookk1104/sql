-- 테이블 생성방법
-- CREATE TABLE 테이블이름 (컬럼이름 자료형(크기), 컬럼이름 자료형(크기)....)
/*콤마[,]를 찍으면 다음 컬럼이 있다는 의미, 마지막은 안 찍음
CREATE TABLE 테이블이름(
    컬럼이름    자료형(크기),
    컬럼이름    자료형(크기),
    컬럼이름    자료형(크기)
)
*/
CREATE TABLE MEMBER(
    MEMBER_ID   VARCHAR2(20), -- 아이디/패스워드는 가변문자VARCHAR2타입
    MEMBER_PW   VARCHAR2(20), -- 고정문자CHAR로 정의하면 최대크기보다 작게 입력했을 때 공백이 생김
    MEMBER_NAME VARCHAR2(21)
);
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디'; -- 컬럼에 대한 설명
COMMENT ON COLUMN MEMBER.MEMBER_PW IS '회원비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';
INSERT INTO MEMBER VALUES('user01','1234','유저1');
SELECT * FROM MEMBER;

CREATE TABLE USER_NOCONS(
    USER_NO     NUMBER,
    USER_ID     VARCHAR2(20),
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6),
    PHONE       CHAR(11)
);
INSERT INTO USER_NOCONS VALUES(1,'user01','1234','유저1','여자','01011111111');
INSERT INTO USER_NOCONS VALUES(2,'user02',null,null,'남자','01022222222');
SELECT * FROM USER_NOCONS;


-- NOTNULL : NULL값 입력 불가
CREATE TABLE USER_NOTNULL(
    USER_NO     NUMBER,
    USER_ID     VARCHAR2(20) NOT NULL,
    USER_PW     VARCHAR2(30) NOT NULL,
    USER_NAME   VARCHAR2(30) NOT NULL,
    GENDER      CHAR(6),
    PHONE       CHAR(11)
);
INSERT INTO USER_NOTNULL VALUES(1,'user01','1234','유저1','남자','01011111111');
INSERT INTO USER_NOTNULL VALUES(2,'user02','1234','유저2',NULL,'01022222222');
SELECT * FROM USER_NOTNULL;


-- UNIQUE : 해당컬럼값의 중복을 제한
SELECT * FROM USER_NOCONS;
INSERT INTO USER_NOCONS VALUES(3,'user01','1234','중복','남자','01011111111');

CREATE TABLE USER_UNIQUE(
    USER_NO     NUMBER UNIQUE NOT NULL, -- UNIQUE 컬럼레벨설정
    USER_ID     VARCHAR2(20) NOT NULL,  -- NOT NULL은 컬럼레벨설정만 가능
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6),
    PHONE       CHAR(11),
    UNIQUE(USER_ID)            -- UNIQUE 테이블레벨설정
);
INSERT INTO USER_UNIQUE VALUES(1,'user01','1111','유저1','남자','01011111111');
INSERT INTO USER_UNIQUE VALUES(2,'user02','2222','유저2','여자','01022222222');
INSERT INTO USER_UNIQUE VALUES(3,NULL,'3333','유저3','여자','01033333333');
INSERT INTO USER_UNIQUE VALUES(4,NULL,'4444','유저4','남자','01044444444');
SELECT * FROM USER_UNIQUE;

CREATE TABLE USER_UNIQUE2(
    USER_NO     NUMBER,
    USER_ID     VARCHAR2(20),
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6),
    PHONE       CHAR(11),
    UNIQUE(USER_NO, USER_ID) -- NO,ID가 동시에! 중복일 때만 UNIQUE제약조건 작동(독립X)
);
INSERT INTO USER_UNIQUE2 VALUES(1,'user01','1111','유저1','남자','01011111111');
INSERT INTO USER_UNIQUE2 VALUES(1,'user02','1234','유저2','남자','01022222222');
INSERT INTO USER_UNIQUE2 VALUES(2,'user01','3333','유저3','여자','01033333333');
SELECT * FROM USER_UNIQUE2;


-- PRIMARY KEY: [NOT NULL+UNIQUE]조건,
-- 한 행의 정보를 구분하기 위한 고유식별자(Identifier)역할을 함, '기본키'
CREATE TABLE USER_PK1(
    USER_NO     NUMBER PRIMARY KEY, -- 컬럼레벨에서 PK설정
    USER_ID     VARCHAR2(20),
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6),
    PHONE       CHAR(11)
);
INSERT INTO USER_PK1 VALUES(1,'user01','1111','유저1','남자','01011111111');
INSERT INTO USER_PK1 VALUES(NULL,'user02','1234','유저2','여자','01022222222');
SELECT * FROM USER_PK1;

CREATE TABLE USER_PK2(
    USER_NO     NUMBER,
    USER_ID     VARCHAR2(20),
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6),
    PHONE       CHAR(11),
    PRIMARY KEY(USER_NO)    -- 테이블레벨에서 PK 설정
);
INSERT INTO USER_PK2 VALUES(1,'user01','1111','유저1','남자','01011111111');
INSERT INTO USER_PK2 VALUES(NULL,'user02','1234','유저2','여자','01022222222');
SELECT * FROM USER_PK2;

CREATE TABLE USER_PK3(
    USER_NO     NUMBER,
    USER_ID     VARCHAR2(20),
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6),
    PHONE       CHAR(11),
    PRIMARY KEY(USER_NO, USER_ID)
    -- 기본키로 정한 NO,ID 둘 중 하나라도 중복과 NULL입력 불가(UNIQUE랑 다른점)
);
INSERT INTO USER_PK3 VALUES(1,'user01','1111','유저1','남자','01011111111');
INSERT INTO USER_PK3 VALUES(NULL,'user02','1234','유저2','여자','01022222222');
INSERT INTO USER_PK3 VALUES(2,NULL,'1234','유저2','여자','01022222222');
SELECT * FROM USER_PK3;


-- FOREIGN KEY : 참조 무결성 유지, '외래키'
CREATE TABLE SHOP_MEMBER(
    USER_NO     NUMBER PRIMARY KEY,
    USER_ID     VARCHAR2(20) UNIQUE NOT NULL,
    USER_PW     VARCHAR2(30) NOT NULL,
    USER_NAME   VARCHAR2(20)
);
INSERT INTO SHOP_MEMBER VALUES(1,'user1','1111','유저1');
INSERT INTO SHOP_MEMBER VALUES(2,'user2','2222','유저2');
INSERT INTO SHOP_MEMBER VALUES(3,'user3','3333','유저3');
SELECT * FROM SHOP_MEMBER;

CREATE TABLE SHOP_BUY1(
    BUY_NO          NUMBER PRIMARY KEY,
    USER_ID         VARCHAR2(20) REFERENCES SHOP_MEMBER(USER_ID),
    -- 외래키 컬럼레벨설정
    PRODUCT_NAME    VARCHAR2(300),
    BUY_DATE        DATE
);
INSERT INTO SHOP_BUY1 VALUES(1,'user1','맥북프로',sysdate-1);
INSERT INTO SHOP_BUY1 VALUES(2,'user2','키보드',sysdate);
INSERT INTO SHOP_BUY1 VALUES(3,'user4','마우스',sysdate);
SELECT * FROM SHOP_BUY1;
UPDATE SHOP_BUY1 SET USER_ID='user4' WHERE BUY_NO=2;

CREATE TABLE SHOP_BUY2(
    BUY_NO          NUMBER PRIMARY KEY,
    USER_ID         VARCHAR2(20),
    PRODUCT_NAME    VARCHAR2(300),
    BUY_DATE        DATE,
    FOREIGN KEY(USER_ID) REFERENCES SHOP_MEMBER(USER_ID)
    -- 외래키 테이블레벨설정
);

CREATE TABLE SHOP_BUY3(
    BUY_NO          NUMBER PRIMARY KEY,
    USER_NO         NUMBER(20) REFERENCES SHOP_MEMBER, -- (USER_NO)PRIMARY KEY는 생략해도 저절로 참조
    PRODUCT_NAME    VARCHAR2(300),
    BUY_DATE        DATE
);
SELECT * FROM SHOP_MEMBER;
SELECT * FROM SHOP_BUY1;
DELETE FROM SHOP_MEMBER WHERE USER_ID = 'user3';
DELETE FROM SHOP_MEMBER WHERE USER_ID = 'user2'; -- SHOP_BUY1에서 참조하고있는 데이터는 안 지워짐

CREATE TABLE SHOP_MEMBER1(
    USER_NO     NUMBER PRIMARY KEY,
    USER_ID     VARCHAR2(20) UNIQUE NOT NULL,
    USER_PW     VARCHAR2(30) NOT NULL,
    USER_NAME   VARCHAR2(20)
);
INSERT INTO SHOP_MEMBER1 VALUES(1,'user1','1111','유저1');
INSERT INTO SHOP_MEMBER1 VALUES(2,'user22','2222','유저2');

CREATE TABLE SHOP_MEMBER2(
    USER_NO     NUMBER PRIMARY KEY,
    USER_ID     VARCHAR2(20) UNIQUE NOT NULL,
    USER_PW     VARCHAR2(30) NOT NULL,
    USER_NAME   VARCHAR2(20)
);
INSERT INTO SHOP_MEMBER2 VALUES(1,'user33','1111','유저3');
INSERT INTO SHOP_MEMBER2 VALUES(2,'user44','2222','유저4');

SELECT * FROM SHOP_MEMBER1
UNION ALL
SELECT * FROM SHOP_MEMBER2;

-- DELETE SET NULL
CREATE TABLE SHOP_BUY_TEST1(
    BUY_NO      NUMBER PRIMARY KEY,
    USER_ID     VARCHAR2(20) REFERENCES SHOP_MEMBER1(USER_ID)ON DELETE SET NULL,
    -- parent key삭제되면 child row가 참조하고있던 값은 null로 대체
    PRODUCT_NAME    VARCHAR2(200),
    BUY_DATE    DATE
);
INSERT INTO SHOP_BUY_TEST1 VALUES(1,'user11','핸드폰',sysdate);
INSERT INTO SHOP_BUY_TEST1 VALUES(2,'user22','노트북',sysdate);
SELECT * FROM SHOP_BUY_TEST1;
SELECT * FROM SHOP_MEMBER1;
DELETE FROM SHOP_MEMBER1 WHERE USER_ID = 'user11';
DELETE FROM SHOP_BUY_TEST1 WHERE BUY_NO = 2;

-- DELETE CASCADE
CREATE TABLE SHOP_BUY_TEST2(
    BUY_NO      NUMBER PRIMARY KEY,
    USER_ID     VARCHAR2(20) REFERENCES SHOP_MEMBER2(USER_ID)ON DELETE CASCADE,
    -- parent key삭제되면 참조하고 있던 child row값(ROW전체)도 사라짐
    PRODUCT_NAME    VARCHAR2(200),
    BUY_DATE    DATE
);
INSERT INTO SHOP_BUY_TEST2 VALUES(1,'user33','커피',sysdate);
INSERT INTO SHOP_BUY_TEST2 VALUES(2,'user44','마우스',sysdate);
INSERT INTO SHOP_BUY_TEST2 VALUES(3,'user44','키보드',sysdate);
SELECT * FROM SHOP_MEMBER2;
SELECT * FROM SHOP_BUY_TEST2;
DELETE FROM SHOP_MEMBER2 WHERE USER_ID = 'user44';

-- CHECK : 해당 컬럼에 [설정한 값]만 넣을 수 있게 하는 제약조건
CREATE TABLE USER_CHECK(
    USER_NO     NUMBER,
    USER_ID     VARCHAR2(20),
    USER_PW     VARCHAR2(30),
    USER_NAME   VARCHAR2(30),
    GENDER      CHAR(6) CHECK(GENDER IN('남자','여자')),
    PHONE       CHAR(11)
);
INSERT INTO USER_CHECK VALUES(1,'user01','1234','유저1','남자','01011111111');
INSERT INTO USER_CHECK VALUES(2,'user02','1234','유저2','여자','01022222222');
INSERT INTO USER_CHECK VALUES(3,'user03','1234','유저3',NULL,'01011111113');
SELECT * FROM USER_CHECK;
